<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Background</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>Background</h2>

<p>This package is intended to be used in support of data management activities
associated with fixed locations in space. The motivating fields include both
air and water quality monitoring where fixed sensors report at regular time 
intervals.</p>

<p>When working with environmental monitoring time series, one of the first things
you have to do is create unique identifiers for each individual time series. In 
an ideal world, each environmental time series would have both a 
<code>locationID</code> and a <code>sensorID</code> that uniquely identify the spatial location and 
specific instrument making measurements. A unique <code>timeseriesID</code> could
be produced as <code>locationID_sensorID</code>. Location metadata associated with each
time series would contain basic information needed for downstream analysis
including at least:</p>

<p><code>timeseriesID, locationID, sensorID, longitude, latitude, ...</code></p>

<ul>
<li>Multiple sensors placed at a location could be be grouped by <code>locationID</code>.</li>
<li>An extended time series for a mobile sensor would group by <code>sensorID</code>.</li>
<li>Maps would be created using <code>longitude, latitude</code>.</li>
<li>Time series would be accessed from a secondary <code>data</code> table with <code>timeseriesID</code>.</li>
</ul>

<p>Unfortunately, we are rarely supplied with a truly unique and truly spatial 
<code>locationID</code>. Instead we often use <code>sensorID</code> or an associated non-spatial
identifier as a stand-in for <code>locationID</code>.</p>

<p>Complications we have seen include:</p>

<ul>
<li>GPS-reported longitude and latitude can have <em>jitter</em> in the fourth or fifth 
decimal place making it challenging to use them to create a unique <code>locationID</code>.</li>
<li>Sensors are sometimes <em>repositioned</em> in what the scientist considers the &ldquo;same 
location&rdquo;.</li>
<li>Data for a single sensor goes through different processing pipelines using
different identifiers and is later brought together as two separate timeseries.</li>
<li>The radius of what constitutes a &ldquo;single location&rdquo; depends on the 
instrumentation and scientific question being asked.</li>
<li>Deriving location-based metadata from spatial datasets is computationally 
intensive unless saved and identified with a unique <code>locationID</code>.</li>
<li>Automated searches for spatial metadata occasionally produce incorrect results
because of the non-infinite resolution of spatial datasets and must be corrected
by hand.</li>
</ul>

<h2>Functionality</h2>

<p>A solution to all these problems is possible if we store spatial metadata in
simple tables in a standard directory. These tables will be referred to as 
<em>collections</em>. Location lookups can be performed with
geodesic distance calculations where a location is assigned to a pre-existing
<em>known location</em> if it is within <code>radius</code> meters. These will be extremely fast.</p>

<p>If no previously <em>known location</em> is found, the relatively slow (seconds)
creation of a new <em>known location</em> metadata record can be performed and then 
added to the growing collection.</p>

<p>For collections of stationary environmental monitors that only number in the 
thousands, this entire <em>collection</em> (<em>i.e.</em> &ldquo;database&rdquo;) can be stored as either a 
<code>.rda</code> or <code>.csv</code> file and will be under a megabyte in size making it fast to 
load. This small size also makes it possible to store multiple <em>known location</em> 
files, each created with different locations and different radii to address 
the needs of different scientific studies.</p>

<h2>Example Usage</h2>

<p>The package comes with some example <em>known location</em> tables to demonstrate.</p>

<p>Lets take some metadata we have for air quality monitors in Washington state and
create a <em>known location</em> table for them.</p>

<pre><code class="r">wa &lt;- get(data(&quot;wa_airfire_meta&quot;, package = &quot;MazamaLocationUtils&quot;))
names(wa)
</code></pre>

<pre><code>##  [1] &quot;monitorID&quot;             &quot;longitude&quot;             &quot;latitude&quot;             
##  [4] &quot;elevation&quot;             &quot;timezone&quot;              &quot;countryCode&quot;          
##  [7] &quot;stateCode&quot;             &quot;siteName&quot;              &quot;agencyName&quot;           
## [10] &quot;countyName&quot;            &quot;msaName&quot;               &quot;monitorType&quot;          
## [13] &quot;siteID&quot;                &quot;instrumentID&quot;          &quot;aqsID&quot;                
## [16] &quot;pwfslID&quot;               &quot;pwfslDataIngestSource&quot; &quot;telemetryAggregator&quot;  
## [19] &quot;telemetryUnitID&quot;
</code></pre>

<h3>Creating a Known Location table</h3>

<p>We can create a <em>known location</em> table for them with a minimum 500 meter
separation between distinct locations:</p>

<pre><code class="r">library(MazamaLocationUtils)

# Initialize with standard directories
mazama_initialize()
setLocationDataDir(&quot;./data&quot;)

wa_monitors_500 &lt;-
  table_initialize() %&gt;%
  table_addLocation(wa$longitude, wa$latitude, radius = 500) 
</code></pre>

<p>Right now, our <em>known locations</em> table contains only automatically generated
spatial metadata:</p>

<pre><code class="r">names(wa_monitors_500)
</code></pre>

<pre><code>##  [1] &quot;locationID&quot;   &quot;locationName&quot; &quot;longitude&quot;    &quot;latitude&quot;     &quot;elevation&quot;   
##  [6] &quot;countryCode&quot;  &quot;stateCode&quot;    &quot;county&quot;       &quot;timezone&quot;     &quot;houseNumber&quot; 
## [11] &quot;street&quot;       &quot;city&quot;         &quot;zip&quot;
</code></pre>

<h3>Merging external metadata</h3>

<p>Perhaps we would like to import some of the original metadata into our new 
table. This is a very common use case where non-spatial metadata like site name
or agency responsible for a monitor can be added.</p>

<p>Just to make it interesting, let&#39;s assume that our <em>known location</em> table is
already large and we are only providing additional metadata for a subset of the
records.</p>

<pre><code class="r"># Use a subset of the wa metadata
wa_indices &lt;- seq(5,65,5)
wa_sub &lt;- wa[wa_indices,]

# Use a generic name for the location table
locationTbl &lt;- wa_monitors_500

# Find the location IDs associated with our subset
locationID &lt;- table_getLocationID(
  locationTbl, 
  longitude = wa_sub$longitude, 
  latitude = wa_sub$latitude, 
  radius = 500
)

# Now add the &quot;siteName&quot; column for our subset of locations
locationData &lt;- wa_sub$siteName
locationTbl &lt;- table_updateColumn(
  locationTbl, 
  columnName = &quot;siteName&quot;, 
  locationID = locationID, 
  locationData = locationData
)

# Lets see how we did
locationTbl_indices &lt;- table_getRecordIndex(locationTbl, locationID)
locationTbl[locationTbl_indices, c(&quot;city&quot;, &quot;siteName&quot;)]
</code></pre>

<pre><code>## # A tibble: 13 x 2
##    city               siteName                      
##    &lt;chr&gt;              &lt;chr&gt;                         
##  1 Chelan             &quot;Chelan-Woodin Ave&quot;           
##  2 La Crosse          &quot;Lacrosse-Hill St&quot;            
##  3 Tri-Cities         &quot;Kennewick-Metaline&quot;          
##  4 Sunnyside          &quot;Sunnyside-S 16th&quot;            
##  5 Inchelium          &quot;Inchelium&quot;                   
##  6 Wellpinit          &quot;Wellpinit-Spokane Tribe&quot;     
##  7 Lake Forest Park   &quot;Lake Forest Park-Town Center&quot;
##  8 Okanogan County    &quot;Twisp-Glover St&quot;             
##  9 Limestone Junction &quot;Maple Falls-Azure Way&quot;       
## 10 Okanogan County    &quot;Omak-Colville Tribe&quot;         
## 11 Ritzville          &quot;Ritzville-Alder St &quot;         
## 12 Darrington         &quot;Darrington-Fir St&quot;           
## 13 Tukwila            &quot;Tukwila_Allentown&quot;
</code></pre>

<p>Very nice.</p>

<h3>Finding known locations</h3>

<p>The whole point of a know location table is to speed up access to spatial
and other metadata. Here&#39;s how we can use it with a set of longitudes and
latitudes that are not currently in our table.</p>

<pre><code class="r"># Create new locations near our known locations
lons &lt;- jitter(wa_sub$longitude) 
lats &lt;- jitter(wa_sub$latitude)

# Any known locations within 50 meters?
table_getNearestLocation(
  wa_monitors_500,
  longitude = lons,
  latitude = lats,
  radius = 50
) %&gt;% dplyr::pull(city)
</code></pre>

<pre><code>##  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA
</code></pre>

<pre><code class="r"># Any known locations within 500 meters
table_getNearestLocation(
  wa_monitors_500,
  longitude = lons,
  latitude = lats,
  radius = 500
) %&gt;% dplyr::pull(city)
</code></pre>

<pre><code>##  [1] NA                NA                NA                &quot;Sunnyside&quot;      
##  [5] NA                &quot;Wellpinit&quot;       NA                &quot;Okanogan County&quot;
##  [9] NA                &quot;Okanogan County&quot; NA                &quot;Darrington&quot;     
## [13] &quot;Tukwila&quot;
</code></pre>

<pre><code class="r"># How about 5000 meters?
table_getNearestLocation(
  wa_monitors_500,
  longitude = lons,
  latitude = lats,
  radius = 5000
) %&gt;% dplyr::pull(city)
</code></pre>

<pre><code>##  [1] &quot;Chelan&quot;             &quot;La Crosse&quot;          &quot;Tri-Cities&quot;        
##  [4] &quot;Sunnyside&quot;          &quot;Inchelium&quot;          &quot;Wellpinit&quot;         
##  [7] &quot;Lake Forest Park&quot;   &quot;Okanogan County&quot;    &quot;Limestone Junction&quot;
## [10] &quot;Okanogan County&quot;    &quot;Ritzville&quot;          &quot;Darrington&quot;        
## [13] &quot;Tukwila&quot;
</code></pre>

<h2>Standard Setup</h2>

<p>Before using <strong>MazamaLocationUtils</strong> you must first install 
<strong>MazamaSpatialUtils</strong> and then install core spatial data with:</p>

<pre><code class="r">  library(MazamaSpatialUtils)
  setSpatialDataDir(&quot;~/Data/Spatial&quot;)
  installSpatialData()
</code></pre>

<p>Once the required datasets have been installed, the easiest way to set things 
up each session is with:</p>

<pre><code class="r">  library(MazamaLocationUtils)
  mazama_initialize()
  setLocationDataDir(&quot;~/Data/KnownLocations&quot;)
</code></pre>

<p><code>mazama_initialize()</code> assumes spatial data are installed in the standard
location and is just a wrapper for:</p>

<pre><code class="r">  MazamaSpatialUtils::setSpatialDataDir(&quot;~/Data/Spatial&quot;)

  MazamaSpatialUtils::loadSpatialData(&quot;EEZCountries&quot;)
  MazamaSpatialUtils::loadSpatialData(&quot;OSMTimezones&quot;)
  MazamaSpatialUtils::loadSpatialData(&quot;NaturalEarthAdm1&quot;)
  MazamaSpatialUtils::loadSpatialData(&quot;USCensusCounties&quot;)
</code></pre>

<p>Every time you <code>table_save()</code> your location table, a backup will be created
so you can experiment without losing your work. File sizes are pretty tiny
so you don&#39;t have to worry about filling up your disk.</p>

<hr/>

<p>Best wishes for well organized spatial metadata!</p>

</body>

</html>
